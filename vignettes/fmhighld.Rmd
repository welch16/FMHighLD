---
title: "Using FMHighLD"
author:
  - name: Rene Welch
    affiliation: &id2 Department of Biostatistics and Medical Informatics, University of Wisconsin-Madison
    email: rwelch2@wisc.edu
  - name: Kwangmoon Park
    affiliation: &id1 Department of Statistics, University of Wisconsin-Madison    
  - name: S&#252;nd&#252;z Kele&#351
    affiliation:
      - *id1
      - *id2
package: FMHighLD
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Using FMHighLD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---


<meta http-equiv="content-type" content="text/html;charset=utf-8" />


# Overview

In this vignette, we provide a brief overview of the `r Biocpkg("FMHighLD")` package. This package provides a fine-mapping methods for SNPs in high LD by integrating summary statistics with annotation data. To install the package we use: 

```{r how-to-install, include = TRUE, echo = FALSE, eval = FALSE}
BiocManager::install("FMHighLD") # not currently available
remotes::install_github("welch16/FMHighLD", ref = "devel")
```

and to load the package, we use:

```{r use, include = TRUE, echo = TRUE, eval = FALSE}
library(FMHighLD)
```


```{r setup, include = FALSE, echo = FALSE, eval = FALSE}

knitr::opts_chunk$set(include = TRUE, echo = FALSE, eval = TRUE,
  warning = FALSE)

library(magrittr)
library(tidyverse)
library(devtools)
library(flexmix)
library(cowplot)
devtools::load_all() ## remove later

theme_set(cowplot::theme_minimal_grid())

```

# Simulation example

We included in the package the simulation methods from Hardin et. al., 2012 _"A method for generating realistic correlation matrices"_. We can utilize these methods to benchmark the `FMHighLD` algorithm.

```{r example, include = FALSE, eval = FALSE}

set.seed(12345)
nsnps <- 2000
nldblocks <- 200
annot_beta <- c("(Intercept)" = 0, "skew" =  3)

snp_data <- simulate_FMHighLD_simple(nsnps, nldblocks, 0.2, 0.1, 2,
  .5, .9, 4, 1^2, annot_beta, .5^2)

snp_names <- snp_data$snp

response <- snp_data$z
names(response) <- snp_names

skew_mat <- build_design_matrix(snp_data, annot_beta)
skew_mat <- as.matrix(skew_mat[, 2], ncol = 1)
rownames(skew_mat) <- snp_names
colnames(skew_mat) <- c("annot")

ld_clusters <- snp_data$ld_cluster
names(ld_clusters) <- snp_names

fmparam <- FMParam(strategy = "all",
    prob = .95,
    min_tol = 1e-3, max_iter = 500, annot_tol = 1e-2)

tictoc::tic()
fmld_fit_em <- fmhighld_fit_em(
  response, skew_mat, ld_clusters,
  singletrait = TRUE,
  formula = response ~ 1 + annot,
  fm_param = fmparam,
  save_iter = TRUE, verbose = TRUE)
tictoc::toc()


true_data <- snp_data %>%
  dplyr::filter(causal == 1) %>%
  dplyr::select((-causal))

true_model <- lm(z ~ 1 + skew, data = as.data.frame(true_data) %>%
  tibble::column_to_rownames("snp"))
summary(true_model)


tictoc::tic()
fmld_fit_lm <- fmhighld_fit(
  response, skew_mat, ld_clusters,
  singletrait = TRUE,
  formula = response ~ 1 + annot,
  init_coef_mean = c(0, 3),
  fm_param = fmparam,
  save_iter = TRUE, verbose = TRUE)
tictoc::toc()

iter_like <- dplyr::bind_rows(
  build_loglike_tibble(fmld_fit_em) %>%
    dplyr::mutate(method = "em"),
  build_loglike_tibble(fmld_fit_lm) %>%
    dplyr::mutate(method = "lm"))

cowplot::plot_grid(
    iter_like %>%
      ggplot(aes(id, loglike)) + geom_line() +
        theme(axis.title.x = element_blank(), legend.position = "none") +
        facet_grid(rows = vars(method), scales = "free_y") +
        scale_color_brewer(palette = "Set1"),
    iter_like %>%
      ggplot(aes(id, diff)) + geom_line() +
      theme(axis.title.x = element_blank(), legend.position = "none") +
        facet_grid(rows = vars(method), scales = "free_y") +
      scale_color_brewer(palette = "Set1"), ncol = 1)

best_iter <- iter_like %>%
  dplyr::group_by(method) %>%
  top_n(1, diff)
  

# true_data

# causal_tibble <- function(fit) {

#   tibble::tibble(
#     ld_cluster = names(fit@causal_candidates[[1]]),
#     snp_causal = fit@causal_candidates[[1]])

# }

# true_data %>%
#   inner_join(causal_tibble(fmld_fit)) %>%
#   dplyr::filter(snp != snp_causal)
  


  

# tt <- replicate(500, {

#   fmodel1 <- flexmix::FLXMRglm(~ skew, family = "gaussian")
#   fmodel2 <- flexmix::FLXMRglm(family = "gaussian")
#   # fmodel3 <- flexmix::FLXMRglm(~ 0 + skew, family = "gaussian")

#   data <- snp_data %>%
#     group_by(ld_cluster) %>%
#     sample_n(1) %>%
#     ungroup()

#   flexfit <- flexmix(z ~ 1, k = 2, data = data,
#     model = list(fmodel1, fmodel2))

# })

# tt  %>%
#   map(relabel) %>%
#   map(parameters) %>%
#   map(1) %>%
#   map_dbl(~.[2,1]) %>%
#   tibble(x = .) %>%
#   ggplot(aes(x))+ geom_histogram(bins = 21) +
#   geom_vline(xintercept = 1, linetype = 2, colour = "red")

# algorithm 
# 0. take seed
# 1. fit flexmix model cem
# 2. among the snps that are in the slope model pick the snps
#     that are closest to linear model
# 3. repeat until convergence?

# flexmix::predict(tt[[1]], data =newdata) %>% str()

# tt %>% map(parameters) %>% pluck(3)
 
# AIC(fit_model)
# BIC(fit_model)

# flexmix::predict(fit_model) %>% str


# fit_model %>% class

# fit_model0 <- flexmix::initFlexmix(z ~ skew, nrep = 10, k = 2,
#   data = snp_data, model = list(fmodel1, fmodel2))

# fit_model1 <- flexmix::stepFlexmix(z ~ skew, nrep = 10, k = 2,
#   data = snp_data, model = list(fmodel1, fmodel2))

# parameters(fit_model0)
# parameters(fit_model1)

# # flexmix::FLXMRglm
# pps <- parameters(flexfit)

# snp_data %>%
#   dplyr::mutate(cl = flexmix::clusters(fit_model)) %>%
#   dplyr::select(causal, cl) %>%
#   table()


```



```{r skew-vs-z, include = FALSE, echo = FALSE, eval = FALSE}



true_data %<>%
  dplyr::mutate(res = residuals(true_model)[true_data$snp]^2)
true_param <- coef(summary(true_model))[, "Estimate"]

pps <- best_iter %>%
  dplyr::filter(method == "em") %>%
  dplyr::pull(id)

pps <- fmld_fit_em$all_models[[pps]] %>%
  flexmix::relabel() %>%
  flexmix::parameters()

pps2 <- best_iter %>%
  dplyr::filter(method == "lm") %>%
  dplyr::pull(id)

pps2 <- fmld_fit_lm$all_models[[pps2]] %>%
  models()

snp_data %>%
  ggplot(aes(skew, z, colour = factor(causal))) +
  geom_point() +
  scale_color_manual(values = c(`1` = "navyblue", `0` = "lightgray")) +
  theme_minimal() +
  theme(legend.position = "top") +
  labs(colour = "causal", x = "skew", y = "z") +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_smooth(method = "lm", formula = y ~ 1 + x, se = FALSE,
    aes(group = 1), colour = "red") +
  geom_abline(slope = true_param[2], intercept = true_param[1],
    colour = "darkgreen") +
  geom_abline(slope = pps[[1]][2, 1], intercept = pps[[1]][1, 1],
    colour = "steelblue") +
  geom_abline(slope = coef(pps2[[1]])[2], intercept = coef(pps2[[1]])[1],
    colour = "magenta")
    
```

```{r skew-vs-z-strat, include = FALSE, echo = FALSE, eval = FALSE}

snp_data %>%
  dplyr::mutate(ld_cluster = forcats::fct_reorder(ld_clusters,
    as.numeric(stringr::str_remove(ld_clusters, "ld")))) %>%
  ggplot(aes(skew, z, size = factor(causal))) +
  geom_point() +
  scale_size_manual(values = c(`1` = 3, `0` = 1)) +
  theme_bw() +
  theme(legend.position = "top") +
  labs(x = "skew", y = "z") +
  facet_wrap(~ ld_cluster, nrow = 5) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  ggrepel::geom_text_repel(aes(label = snp), colour = "black", size = 3)
  

```

```{r, include=FALSE,echo=FALSE,eval=FALSE}

linear_model <- function(data) {

  lm(z ~ 0 + skew, data = data) %>%
    coef()

}

nsims <- 1e3
set.seed(123)
ss <- replicate(nsims, {
  snp_data %>%
    group_by(ld_cluster) %>%
    sample_n(1) %>%
    linear_model()
})

truth <- snp_data %>% filter(causal == 1) %>% linear_model()


tibble(ss) %>%
  ggplot(aes(ss)) + geom_histogram() +
  geom_vline(xintercept = truth, colour = "red", linetype = 2) +
  theme(axis.title.x = element_blank())
  


# out of 5e3 replications, there is no version getting a close value to the
# true slope

# the truth gets something close, so the linear model coefficients
# are valuable as a proxy of the true causals


```


# SessionInfo

```{r info,include=TRUE,echo =TRUE,eval=TRUE}
sessioninfo::session_info("FMHighLD")
```
